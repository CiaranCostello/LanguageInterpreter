
==================== FINAL INTERFACE ====================
2017-01-15 16:45:53.375113 UTC

interface interpreter-0.1.0.0-GqnoMtv2RfEKuRoO5Q8gRz:InterpreterBase 8001
  interface hash: a40fa6b6fc229a1e46364ca6dcd6e4fb
  ABI hash: fc106bdd56ca5a3ea148524627c37a29
  export-list hash: 70553b149ed7a63dddb7d67238273153
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 5d0384261942ab4b8e8bd9c9cd4d2eec
  sig of: Nothing
  used TH splices: False
  where
exports:
  InterpreterBase.bool
  InterpreterBase.eval
  InterpreterBase.evalb
  InterpreterBase.evali
  InterpreterBase.evalib
  InterpreterBase.exec
  InterpreterBase.execCheck
  InterpreterBase.inspectHistory
  InterpreterBase.int
  InterpreterBase.lookup
  InterpreterBase.printEnvironment
  InterpreterBase.record
  InterpreterBase.reverse
  InterpreterBase.rewind
  InterpreterBase.run
  InterpreterBase.runEval
  InterpreterBase.runInspect
  InterpreterBase.runRun
  InterpreterBase.set
  InterpreterBase.var
  InterpreterBase.BigEnv
  InterpreterBase.Env
  InterpreterBase.Eval
  InterpreterBase.Expr{InterpreterBase.Add InterpreterBase.And InterpreterBase.Const InterpreterBase.Div InterpreterBase.Eq InterpreterBase.Gt InterpreterBase.Lt InterpreterBase.Mul InterpreterBase.Not InterpreterBase.Or InterpreterBase.Sub InterpreterBase.Var}
  InterpreterBase.Name
  InterpreterBase.PrettyExpr{InterpreterBase..* InterpreterBase..-}
  InterpreterBase.Run
  InterpreterBase.SmartAssignment{InterpreterBase.assign}
  InterpreterBase.Statement{InterpreterBase.Assign InterpreterBase.If InterpreterBase.Pass InterpreterBase.Print InterpreterBase.Seq InterpreterBase.Try InterpreterBase.While}
  InterpreterBase.Val{InterpreterBase.B InterpreterBase.I}
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0*
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  base-4.9.0.0:Control.Monad.IO.Class d702028d883e700bd7066b031147030d
import  -/  base-4.9.0.0:Data.Either bd9f099b82d4ed2d98c56d7144ac6957
import  -/  base-4.9.0.0:Data.Functor.Identity eef8b7d6233156345b1fd0db19552a3c
import  -/  base-4.9.0.0:Data.Maybe 5f2ba364cbe65c060bc5436bc0b9d049
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Read 817c914615ac8e308afc0c675fb3f671
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:System.IO eb1d40aa793a4047069a5023f2ebcfe3
import  -/  base-4.9.0.0:Text.ParserCombinators.ReadPrec 9512e2f4b227f507f87a150887202aed
import  -/  base-4.9.0.0:Text.Read.Lex fe3dd7b823826bf6870140c5363f9596
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 24b19ef74cea78e4c18332bed9f0491d
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base 1e8d61dcc59a1a983b27bab6fd6bdcaf
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Error.Class f139fe3464686c34428880c6a5173636
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Except 99ba8f4995df0e7f2f512551a0ca666a
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Identity d5df288a645143a1a126ce2ea9106b82
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Reader 859b39f57eb3bed457106c30aac21473
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Reader.Class a2c7beb266585be238cfe9f5989c52b7
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State d851912d62cbc95e043a9cc13c3581de
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State.Class b303b4a4ee6363bc95266312b9afc751
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.Writer 57defc881a9014c3d1c218e1b5d9eb02
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Except 71b1d86204f6908788cb5223e3c73193
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Reader e4096b104cf1a0df8752e81669ef6a24
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 16a585e7f12cd771300b3cab638df233
9411e785bedd7f51dc2f15a10ee49dce
  $fEqExpr :: GHC.Classes.Eq InterpreterBase.Expr
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Expr
                  InterpreterBase.$fEqExpr_$c==
                  InterpreterBase.$fEqExpr_$c/= -}
9411e785bedd7f51dc2f15a10ee49dce
  $fEqExpr_$c/= ::
    InterpreterBase.Expr -> InterpreterBase.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: InterpreterBase.Expr) (b :: InterpreterBase.Expr) ->
                 case InterpreterBase.$fEqExpr_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fEqExpr_$c== ::
    InterpreterBase.Expr -> InterpreterBase.Expr -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fEqStatement :: GHC.Classes.Eq InterpreterBase.Statement
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Statement
                  InterpreterBase.$fEqStatement_$c==
                  InterpreterBase.$fEqStatement_$c/= -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fEqStatement_$c/= ::
    InterpreterBase.Statement
    -> InterpreterBase.Statement -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: InterpreterBase.Statement)
                   (b :: InterpreterBase.Statement) ->
                 case InterpreterBase.$fEqStatement_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fEqStatement_$c== ::
    InterpreterBase.Statement
    -> InterpreterBase.Statement -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fEqVal :: GHC.Classes.Eq InterpreterBase.Val
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Val
                  InterpreterBase.$fEqVal_$c==
                  InterpreterBase.$fEqVal_$c/= -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fEqVal_$c/= ::
    InterpreterBase.Val -> InterpreterBase.Val -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: InterpreterBase.Val)
                   (b :: InterpreterBase.Val) ->
                 case a of wild {
                   InterpreterBase.I a1
                   -> case b of wild1 {
                        InterpreterBase.I b1
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }
                        InterpreterBase.B ipv -> GHC.Types.True }
                   InterpreterBase.B a1
                   -> case b of wild1 {
                        InterpreterBase.I ipv -> GHC.Types.True
                        InterpreterBase.B b1
                        -> case a1 of wild2 {
                             GHC.Types.False -> b1
                             GHC.Types.True
                             -> case b1 of wild3 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True -> GHC.Types.False } } } }) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fEqVal_$c== ::
    InterpreterBase.Val -> InterpreterBase.Val -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: InterpreterBase.Val)
                   (ds1 :: InterpreterBase.Val) ->
                 case ds of wild {
                   InterpreterBase.I a1
                   -> case ds1 of wild1 {
                        InterpreterBase.I b1 -> GHC.Classes.eqInt a1 b1
                        InterpreterBase.B ipv -> GHC.Types.False }
                   InterpreterBase.B a1
                   -> case ds1 of wild1 {
                        InterpreterBase.I ipv -> GHC.Types.False
                        InterpreterBase.B b1 -> GHC.Classes.$fEqBool_$c== a1 b1 } }) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fMonoidStatement :: GHC.Base.Monoid InterpreterBase.Statement
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Statement
                  InterpreterBase.Pass
                  InterpreterBase.Seq
                  InterpreterBase.$fMonoidStatement_$cmconcat -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fMonoidStatement_$cmconcat ::
    [InterpreterBase.Statement] -> InterpreterBase.Statement
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (eta :: [InterpreterBase.Statement]) ->
                 InterpreterBase.$fMonoidStatement_go eta) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fMonoidStatement_go ::
    [InterpreterBase.Statement] -> InterpreterBase.Statement
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c233ce56ce8faf27062c926a50e2b5e7
  $fPrettyExpr[]Int ::
    InterpreterBase.PrettyExpr GHC.Base.String GHC.Types.Int
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Base.String
                  @ GHC.Types.Int
                  InterpreterBase.$fPrettyExpr[]Int_$c.*
                  InterpreterBase.$fPrettyExpr[]Int_$c.- -}
7a4d3e616bf49c72753827375dd2251f
  $fPrettyExpr[]Int_$c.* ::
    GHC.Base.String -> GHC.Types.Int -> InterpreterBase.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.String) (y :: GHC.Types.Int) ->
                 InterpreterBase.Mul
                   (InterpreterBase.Var x)
                   (InterpreterBase.Const (InterpreterBase.I y))) -}
d34d92ddab7f91b06c60a4cc9ff72efb
  $fPrettyExpr[]Int_$c.- ::
    GHC.Base.String -> GHC.Types.Int -> InterpreterBase.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m3,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.String) (y :: GHC.Types.Int) ->
                 InterpreterBase.Sub
                   (InterpreterBase.Var x)
                   (InterpreterBase.Const (InterpreterBase.I y))) -}
c233ce56ce8faf27062c926a50e2b5e7
  $fPrettyExpr[][] ::
    InterpreterBase.PrettyExpr GHC.Base.String GHC.Base.String
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ GHC.Base.String
                  @ GHC.Base.String
                  InterpreterBase.$fPrettyExpr[][]_$c.*
                  InterpreterBase.$fPrettyExpr[][]_$c.- -}
a87891617f3ad387f0bacfd5bca3e1b3
  $fPrettyExpr[][]_$c.* ::
    GHC.Base.String -> GHC.Base.String -> InterpreterBase.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.String) (y :: GHC.Base.String) ->
                 InterpreterBase.Mul
                   (InterpreterBase.Var x)
                   (InterpreterBase.Var y)) -}
ba7824d2596220062d7f58b2ab37737d
  $fPrettyExpr[][]_$c.- ::
    GHC.Base.String -> GHC.Base.String -> InterpreterBase.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m3,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.String) (y :: GHC.Base.String) ->
                 InterpreterBase.Sub
                   (InterpreterBase.Var x)
                   (InterpreterBase.Var y)) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr :: GHC.Read.Read InterpreterBase.Expr
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Expr
                  InterpreterBase.$fReadExpr_$creadsPrec
                  InterpreterBase.$fReadExpr_$creadList
                  InterpreterBase.$fReadExpr_$creadPrec
                  InterpreterBase.$fReadExpr_$creadListPrec -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([InterpreterBase.Expr] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [InterpreterBase.Expr]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ InterpreterBase.Expr
                   InterpreterBase.$fReadExpr2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <InterpreterBase.Expr>_R))
                   @ b
                   eta1) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP InterpreterBase.Expr
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ InterpreterBase.Expr
                   InterpreterBase.$fReadExpr3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <InterpreterBase.Expr>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <InterpreterBase.Expr>_R)))) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (InterpreterBase.Expr -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: InterpreterBase.Expr -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 InterpreterBase.$w$creadPrec ww1 @ b w1 }) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr4 ::
    Text.ParserCombinators.ReadP.P [InterpreterBase.Expr]
  {- Unfolding: (GHC.Read.$wlist
                   @ InterpreterBase.Expr
                   InterpreterBase.$fReadExpr2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <InterpreterBase.Expr>_R))
                   @ [InterpreterBase.Expr]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [InterpreterBase.Expr])) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [InterpreterBase.Expr]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [InterpreterBase.Expr]
                   InterpreterBase.$fReadExpr4) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [InterpreterBase.Expr]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.$fReadExpr1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[InterpreterBase.Expr]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[InterpreterBase.Expr]>_R))) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec InterpreterBase.Expr
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.$fReadExpr2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <InterpreterBase.Expr>_R)) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fReadExpr_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS InterpreterBase.Expr
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ InterpreterBase.Expr
                   ((GHC.Read.$fReadDouble10
                       @ InterpreterBase.Expr
                       InterpreterBase.$fReadExpr3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <InterpreterBase.Expr>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <InterpreterBase.Expr>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <InterpreterBase.Expr>_R)
                      @ InterpreterBase.Expr
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ InterpreterBase.Expr))) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement :: GHC.Read.Read InterpreterBase.Statement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Statement
                  InterpreterBase.$fReadStatement_$creadsPrec
                  InterpreterBase.$fReadStatement_$creadList
                  InterpreterBase.$fReadStatement_$creadPrec
                  InterpreterBase.$fReadStatement_$creadListPrec -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([InterpreterBase.Statement] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [InterpreterBase.Statement]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ InterpreterBase.Statement
                   InterpreterBase.$fReadStatement2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <InterpreterBase.Statement>_R))
                   @ b
                   eta1) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP InterpreterBase.Statement
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ InterpreterBase.Statement
                   InterpreterBase.$fReadStatement3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <InterpreterBase.Statement>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <InterpreterBase.Statement>_R)))) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (InterpreterBase.Statement -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)> -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement4 ::
    Text.ParserCombinators.ReadP.P [InterpreterBase.Statement]
  {- Unfolding: (GHC.Read.$wlist
                   @ InterpreterBase.Statement
                   InterpreterBase.$fReadStatement2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <InterpreterBase.Statement>_R))
                   @ [InterpreterBase.Statement]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [InterpreterBase.Statement])) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [InterpreterBase.Statement]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [InterpreterBase.Statement]
                   InterpreterBase.$fReadStatement4) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [InterpreterBase.Statement]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.$fReadStatement1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[InterpreterBase.Statement]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[InterpreterBase.Statement]>_R))) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec InterpreterBase.Statement
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.$fReadStatement2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <InterpreterBase.Statement>_R)) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fReadStatement_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS InterpreterBase.Statement
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ InterpreterBase.Statement
                   ((GHC.Read.$fReadDouble10
                       @ InterpreterBase.Statement
                       InterpreterBase.$fReadStatement3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <InterpreterBase.Statement>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <InterpreterBase.Statement>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <InterpreterBase.Statement>_R)
                      @ InterpreterBase.Statement
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ InterpreterBase.Statement))) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal :: GHC.Read.Read InterpreterBase.Val
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Val
                  InterpreterBase.$fReadVal_$creadsPrec
                  InterpreterBase.$fReadVal_$creadList
                  InterpreterBase.$fReadVal_$creadPrec
                  InterpreterBase.$fReadVal_$creadListPrec -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([InterpreterBase.Val] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [InterpreterBase.Val]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ InterpreterBase.Val
                   InterpreterBase.$fReadVal2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <InterpreterBase.Val>_R))
                   @ b
                   eta1) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP InterpreterBase.Val
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ InterpreterBase.Val
                   InterpreterBase.$fReadVal3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <InterpreterBase.Val>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <InterpreterBase.Val>_R)))) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (InterpreterBase.Val -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: InterpreterBase.Val -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 InterpreterBase.$w$creadPrec1 ww1 @ b w1 }) -}
d4649bcb6ca7f826d2b346eec8ea843f
  $fReadVal4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "I"#) -}
2c842131ac14f17889cce380006cc357
  $fReadVal5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
593c2dc8147b34e934ca7318440b8ca7
  $fReadVal6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "B"#) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal7 :: Text.ParserCombinators.ReadP.P [InterpreterBase.Val]
  {- Unfolding: (GHC.Read.$wlist
                   @ InterpreterBase.Val
                   InterpreterBase.$fReadVal2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <InterpreterBase.Val>_R))
                   @ [InterpreterBase.Val]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [InterpreterBase.Val])) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [InterpreterBase.Val]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [InterpreterBase.Val]
                   InterpreterBase.$fReadVal7) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [InterpreterBase.Val]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.$fReadVal1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[InterpreterBase.Val]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[InterpreterBase.Val]>_R))) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec InterpreterBase.Val
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.$fReadVal2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <InterpreterBase.Val>_R)) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fReadVal_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS InterpreterBase.Val
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ InterpreterBase.Val
                   ((GHC.Read.$fReadDouble10
                       @ InterpreterBase.Val
                       InterpreterBase.$fReadVal3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <InterpreterBase.Val>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <InterpreterBase.Val>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <InterpreterBase.Val>_R)
                      @ InterpreterBase.Val
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ InterpreterBase.Val))) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fShowExpr :: GHC.Show.Show InterpreterBase.Expr
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Expr
                  InterpreterBase.$fShowExpr_$cshowsPrec
                  InterpreterBase.$fShowExpr_$cshow
                  InterpreterBase.$fShowExpr_$cshowList -}
9411e785bedd7f51dc2f15a10ee49dce
  $fShowExpr1 :: InterpreterBase.Expr -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: InterpreterBase.Expr)
                   (w1 :: GHC.Base.String) ->
                 InterpreterBase.$w$cshowsPrec 0# w w1) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fShowExpr_$cshow :: InterpreterBase.Expr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: InterpreterBase.Expr) ->
                 InterpreterBase.$fShowExpr_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fShowExpr_$cshowList :: [InterpreterBase.Expr] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ InterpreterBase.Expr
                   InterpreterBase.$fShowExpr1) -}
9411e785bedd7f51dc2f15a10ee49dce
  $fShowExpr_$cshowsPrec ::
    GHC.Types.Int -> InterpreterBase.Expr -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: InterpreterBase.Expr)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 InterpreterBase.$w$cshowsPrec ww1 w1 w2 }) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fShowStatement :: GHC.Show.Show InterpreterBase.Statement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Statement
                  InterpreterBase.$fShowStatement_$cshowsPrec
                  InterpreterBase.$fShowStatement_$cshow
                  InterpreterBase.$fShowStatement_$cshowList -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fShowStatement1 :: InterpreterBase.Statement -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (InterpreterBase.$fShowStatement_$cshowsPrec
                   InterpreterBase.$fShowStatement2) -}
7718df4484c61a578809c7ceace47481
  $fShowStatement2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fShowStatement_$cshow ::
    InterpreterBase.Statement -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: InterpreterBase.Statement) ->
                 InterpreterBase.$fShowStatement_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fShowStatement_$cshowList ::
    [InterpreterBase.Statement] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ InterpreterBase.Statement
                   InterpreterBase.$fShowStatement1) -}
e0267278ada4d2cecb8ff825d2e2d0d6
  $fShowStatement_$cshowsPrec ::
    GHC.Types.Int -> InterpreterBase.Statement -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fShowVal :: GHC.Show.Show InterpreterBase.Val
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ InterpreterBase.Val
                  InterpreterBase.$fShowVal_$cshowsPrec
                  InterpreterBase.$fShowVal_$cshow
                  InterpreterBase.$fShowVal_$cshowList -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fShowVal1 :: InterpreterBase.Val -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: InterpreterBase.Val) (w1 :: GHC.Base.String) ->
                 InterpreterBase.$w$cshowsPrec1 0# w w1) -}
46acf9638aeea36b66aeb441e8d618aa
  $fShowVal2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "B "#) -}
57ee21ea30e37be9c01d460b6612ea66
  $fShowVal3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "I "#) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fShowVal_$cshow :: InterpreterBase.Val -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: InterpreterBase.Val) ->
                 InterpreterBase.$fShowVal_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fShowVal_$cshowList :: [InterpreterBase.Val] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ InterpreterBase.Val
                   InterpreterBase.$fShowVal1) -}
2592df2e4af9c4d9ca32f8d54a825baa
  $fShowVal_$cshowsPrec ::
    GHC.Types.Int -> InterpreterBase.Val -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: InterpreterBase.Val)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 InterpreterBase.$w$cshowsPrec1 ww1 w1 w2 }) -}
e26a477f09bab757a207f96a82b27b42
  $fSmartAssignmentBool ::
    InterpreterBase.SmartAssignment GHC.Types.Bool
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m1,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InterpreterBase.$fSmartAssignmentBool_$cassign
                  `cast`
                (Sym (InterpreterBase.N:SmartAssignment[0] <GHC.Types.Bool>_N)) -}
33fac4deff05eb92157e3097af7b618c
  $fSmartAssignmentBool_$cassign ::
    GHC.Base.String -> GHC.Types.Bool -> InterpreterBase.Statement
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m1,
     Unfolding: InlineRule (2, True, False)
                (\ (v :: GHC.Base.String) (b :: GHC.Types.Bool) ->
                 InterpreterBase.Assign
                   v
                   (InterpreterBase.Const (InterpreterBase.B b))) -}
e26a477f09bab757a207f96a82b27b42
  $fSmartAssignmentExpr ::
    InterpreterBase.SmartAssignment InterpreterBase.Expr
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m1,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InterpreterBase.Assign
                  `cast`
                (Sym (InterpreterBase.N:SmartAssignment[0]
                          <InterpreterBase.Expr>_N)) -}
e26a477f09bab757a207f96a82b27b42
  $fSmartAssignmentInt ::
    InterpreterBase.SmartAssignment GHC.Types.Int
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m1,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InterpreterBase.$fSmartAssignmentInt_$cassign
                  `cast`
                (Sym (InterpreterBase.N:SmartAssignment[0] <GHC.Types.Int>_N)) -}
da10706b8f8e1a17a4bf1004ce5e76f3
  $fSmartAssignmentInt_$cassign ::
    GHC.Base.String -> GHC.Types.Int -> InterpreterBase.Statement
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m1,
     Unfolding: InlineRule (2, True, False)
                (\ (v :: GHC.Base.String) (i :: GHC.Types.Int) ->
                 InterpreterBase.Assign
                   v
                   (InterpreterBase.Const (InterpreterBase.I i))) -}
4bdfcf22d91ee6e5ae5cc131cde4bdd7
  $s$fShow[] :: GHC.Show.Show [InterpreterBase.Val]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [InterpreterBase.Val]
                  InterpreterBase.$s$fShow[]_$s$fShow[]_$cshowsPrec
                  InterpreterBase.$s$fShow[]_$s$fShow[]_$cshow
                  InterpreterBase.$s$fShow[]_$s$fShow[]_$cshowList -}
5cf2e67ed4e0ba6be281d7adf637de94
  $s$fShow[]_$s$fShow[]_$cshow ::
    [InterpreterBase.Val] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [InterpreterBase.Val]) ->
                 InterpreterBase.$fShowVal_$cshowList
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6ed8c85b257cc2ba1a9a076c3a2a0950
  $s$fShow[]_$s$fShow[]_$cshow1 ::
    [InterpreterBase.Statement] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [InterpreterBase.Statement]) ->
                 InterpreterBase.$fShowStatement_$cshowList
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
353082cf22891eb085d265a4f2c90349
  $s$fShow[]_$s$fShow[]_$cshowList ::
    [[InterpreterBase.Val]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [[InterpreterBase.Val]]) (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ [InterpreterBase.Val]
                   InterpreterBase.$fShowVal_$cshowList
                   eta
                   eta1) -}
40acec59dbb771f5439a0659749fa6c9
  $s$fShow[]_$s$fShow[]_$cshowsPrec ::
    GHC.Types.Int -> [InterpreterBase.Val] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Int)
                   (eta :: [InterpreterBase.Val])
                   (eta1 :: GHC.Base.String) ->
                 InterpreterBase.$fShowVal_$cshowList eta eta1) -}
9c1d1e815e19490b245cbb05d8f47944
  $sinsertWith_$sgo10 ::
    (InterpreterBase.Name -> a1 -> a1 -> a1)
    -> InterpreterBase.Name
    -> a1
    -> Data.Map.Base.Map InterpreterBase.Name a1
    -> Data.Map.Base.Map InterpreterBase.Name a1
  {- Arity: 4, Strictness: <L,1*C1(C1(C1(U)))><S,1*U><L,U><S,1*U> -}
e08a0de3e4924f1617904b6398e80880
  $slookup1 ::
    [GHC.Types.Char]
    -> Data.Map.Base.Map [GHC.Types.Char] a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
3264e3ba330064940bf14961886ea431
  $tc'Add :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6773165203076005469##
                   3299061297839213388##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Add1) -}
e16792a6cffbcb871fae81fac953e365
  $tc'Add1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Add"#) -}
e098f81d5c6747871a6c0072652a427e
  $tc'And :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5206512537798847656##
                   8100673166697646518##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'And1) -}
834e5f4cff82fb4781e09ea8781dc107
  $tc'And1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'And"#) -}
f3ce6a7abe9e1e5f3d98f03c6e172dcc
  $tc'Assign :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10784924050879178903##
                   7835353643653799852##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Assign1) -}
59ca01d53647812879c9c124dcd207a4
  $tc'Assign1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Assign"#) -}
7fd5752975c19a0dd6cc5532ecaef6e1
  $tc'B :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15551991713553502637##
                   9512615140945006580##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'B1) -}
fcddd9596c801d4b4685642e25a2f507
  $tc'B1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'B"#) -}
127d6c723aaf7d20683b05cb3052e052
  $tc'C:PrettyExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18247367962157719368##
                   9691087377711980243##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'C:PrettyExpr1) -}
9873c0d286bec2e926c4f71e86bd8518
  $tc'C:PrettyExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:PrettyExpr"#) -}
44681d852cfbd481e6edb70c489ed073
  $tc'C:SmartAssignment :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1722116603798391996##
                   6779014604523890688##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'C:SmartAssignment1) -}
6f54aa08f47a1de1cf3a98af97f6fd18
  $tc'C:SmartAssignment1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:SmartAssignment"#) -}
5f781ad32c26c5fcd0d97f932ea1aced
  $tc'Const :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3063391573950863059##
                   9214937465107626999##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Const1) -}
95faf37833d1cac7da9739e2fb3bd55c
  $tc'Const1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Const"#) -}
47e4fbf6252fc6440dca527ab07037d5
  $tc'Div :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15160520712150039562##
                   16597532312425061685##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Div1) -}
05b8edc831ba5d8fcdeb72fedee0ad9c
  $tc'Div1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Div"#) -}
f9377e1c2eb2ec1fab07cad5467dc59d
  $tc'Eq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17624827904632296647##
                   10073436807249016065##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Eq1) -}
b9cd9b3182a8e8b3163084332463f4e1
  $tc'Eq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Eq"#) -}
c5354f0cf1a25e20d4f6311033e6893f
  $tc'Gt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12152657204656372857##
                   14759793511424004291##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Gt1) -}
067f9578c918a36a49fe03f705bf76df
  $tc'Gt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Gt"#) -}
41674c33b1c513d82a03c893432aceac
  $tc'I :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10688698363781685693##
                   3323985265995645654##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'I1) -}
57a012f08a172c232e38c3b874f21787
  $tc'I1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'I"#) -}
86bb76a8c979e9d02a9cdae4e83a502f
  $tc'If :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11779686888030100885##
                   14736043641829761944##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'If1) -}
41d8f83bb0bfde6fa3cc41cd960a42d2
  $tc'If1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'If"#) -}
b94514249f79d708885c8f9f088d98f9
  $tc'Lt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11684631581530014287##
                   10583295255023049552##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Lt1) -}
e432ef903ab11c2137ee4987fb130da8
  $tc'Lt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Lt"#) -}
bcff3808e447aa666fd2cb50b8b9f76a
  $tc'Mul :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1012206004462608497##
                   14866691139211754733##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Mul1) -}
da3f1650efe53998b6e90d72053cbe54
  $tc'Mul1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Mul"#) -}
0fe1b11695561ae8ff00537fd742c788
  $tc'Not :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10454023546155818392##
                   243487237764747455##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Not1) -}
f16b2bc34c15623c6d82a7d6a4249406
  $tc'Not1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Not"#) -}
bd2f8f3879d13ae4cea690b9db9eb207
  $tc'Or :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8635412821781972518##
                   15512119685325157460##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Or1) -}
92ef4255c49f28306f280a899a3a0958
  $tc'Or1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Or"#) -}
0887337bdd7cdabf84d62cf29a4c510f
  $tc'Pass :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3800383226869070280##
                   3963933741926115110##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Pass1) -}
8fe85c132b4ffa585cd5b06e289dca41
  $tc'Pass1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pass"#) -}
d159ee64a1cb87c159e2ddc8e3bf459e
  $tc'Print :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12253152867844401701##
                   816253356980013838##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Print1) -}
a7883f6e0551239977dae693fa7530cf
  $tc'Print1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Print"#) -}
4dcae2ae916562009b54e103c85552c4
  $tc'Seq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6584423633484015142##
                   1466876507267928292##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Seq1) -}
585e4ff65589713a9bdb22ef1dafb26e
  $tc'Seq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Seq"#) -}
67814b30f484fb0dca80b84f7ec96f46
  $tc'Sub :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17326026985892310804##
                   8502209642179058356##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Sub1) -}
eb83ce6ccd8d7e256e7350cf7f307751
  $tc'Sub1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Sub"#) -}
2ae0f4865e88b674fbcd14fe5c4c4931
  $tc'Try :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12495355388339739052##
                   3500098145410199567##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Try1) -}
413cb993e161467670cf55d559fe25c7
  $tc'Try1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Try"#) -}
6fb6f4d523ae1472b7862750e7bca174
  $tc'Var :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9229180291606912150##
                   8340308518551574169##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'Var1) -}
b75fc58e49066b4a5caaa9ed74e95e3c
  $tc'Var1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Var"#) -}
2f0a3a5cf47ebbd2f178986330eab9a2
  $tc'While :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8510933339720270837##
                   15580210098480362204##
                   InterpreterBase.$trModule
                   InterpreterBase.$tc'While1) -}
6353009ae5a028bc6d9f1fe88b079234
  $tc'While1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'While"#) -}
3e86d4e0b4f93df64ef97492aa0c0af7
  $tcExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5033356264942596532##
                   319844539869224698##
                   InterpreterBase.$trModule
                   InterpreterBase.$tcExpr1) -}
6a60ec009a0dc45aee79d2ffdef6dc12
  $tcExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Expr"#) -}
8d9f107289dc2fe980e423ce26f0c874
  $tcPrettyExpr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13599226446007231036##
                   9119288176214179960##
                   InterpreterBase.$trModule
                   InterpreterBase.$tcPrettyExpr1) -}
ee933f42c6605039b09766e04796a89f
  $tcPrettyExpr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "PrettyExpr"#) -}
5c7a641e45b65ee817244d1615220117
  $tcSmartAssignment :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7608932425401792409##
                   1291672730813733889##
                   InterpreterBase.$trModule
                   InterpreterBase.$tcSmartAssignment1) -}
5f3f704ec1134c816036714753dea289
  $tcSmartAssignment1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SmartAssignment"#) -}
60c37db05e441f236feed1dc992bf7cf
  $tcStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16250554189628927765##
                   9926935471872503790##
                   InterpreterBase.$trModule
                   InterpreterBase.$tcStatement1) -}
407fca341546caf088365aeba2a026ae
  $tcStatement1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Statement"#) -}
fc2c45152d77d52f1ef32d06f60a38eb
  $tcVal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12987536927993410153##
                   14192725903458737523##
                   InterpreterBase.$trModule
                   InterpreterBase.$tcVal1) -}
be8584c7e99355f48d387da4d5ca3544
  $tcVal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Val"#) -}
0aa0925b37d42875f2f02f70ebccc11e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   InterpreterBase.$trModule2
                   InterpreterBase.$trModule1) -}
52888dac1b30f914632014d01d3cae50
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "InterpreterBase"#) -}
75805a208056c6d968ab83af7a43aa0a
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "interpreter-0.1.0.0-GqnoMtv2RfEKuRoO5Q8gRz"#) -}
9411e785bedd7f51dc2f15a10ee49dce
  $w$creadPrec ::
    GHC.Prim.Int#
    -> forall b.
       (InterpreterBase.Expr -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0] -}
2592df2e4af9c4d9ca32f8d54a825baa
  $w$creadPrec1 ::
    GHC.Prim.Int#
    -> forall b.
       (InterpreterBase.Val -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   @ b
                   (w :: InterpreterBase.Val -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   karg :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10#) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl80 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl81 :: Text.ParserCombinators.ReadP.P b
                                = GHC.Read.$woptional1
                                    @ b
                                    (\ (a1 :: GHC.Types.Bool) -> w (InterpreterBase.B a1))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                 case a1 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a2
                                   -> case GHC.Base.eqString
                                             a2
                                             InterpreterBase.$fReadVal6 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl81 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl80) -}
                            = \ (w4 :: ()) -> lvl80
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ (a :: GHC.Base.String) ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                               `cast`
                             (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10#) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        karg
                   GHC.Types.True
                   -> let {
                        lvl80 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl81 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadInt3
                                 GHC.Read.$fReadInt_$sconvertInt
                                 InterpreterBase.$fReadVal5)
                                `cast`
                              (Text.ParserCombinators.ReadP.N:ReadP[0] <GHC.Types.Int>_R)
                                @ b
                                (\ (a1 :: GHC.Types.Int) -> w (InterpreterBase.I a1))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ (a1 :: Text.Read.Lex.Lexeme) ->
                             case a1 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a2
                               -> case GHC.Base.eqString a2 InterpreterBase.$fReadVal4 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl81 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl80) -}
                        = \ (w4 :: ()) -> lvl80
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k))
                        karg }) -}
9411e785bedd7f51dc2f15a10ee49dce
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> InterpreterBase.Expr -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0] -}
2592df2e4af9c4d9ca32f8d54a825baa
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> InterpreterBase.Val -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: InterpreterBase.Val)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   InterpreterBase.I b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             InterpreterBase.$fShowVal3
                             (case b1 of ww2 { GHC.Types.I# ww3 ->
                              case GHC.Show.$wshowSignedInt 11# ww3 w1 of ww4 { (#,#) ww5 ww6 ->
                              GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                InterpreterBase.$fShowVal3
                                (case b1 of ww2 { GHC.Types.I# ww3 ->
                                 case GHC.Show.$wshowSignedInt
                                        11#
                                        ww3
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           w1) of ww4 { (#,#) ww5 ww6 ->
                                 GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }
                   InterpreterBase.B b1
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            InterpreterBase.$fShowVal2
                            (case b1 of wild1 {
                               GHC.Types.False -> GHC.Base.++ @ GHC.Types.Char GHC.Show.shows21 x
                               GHC.Types.True
                               -> GHC.Base.++ @ GHC.Types.Char GHC.Show.shows20 x })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)) } }) -}
d152a949bc8dbf16a452fd10f01a847a
  $winspectHistory ::
    InterpreterBase.Statement
    -> [InterpreterBase.Statement]
    -> InterpreterBase.Env
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((), ([InterpreterBase.Statement], InterpreterBase.Env)) #)
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,U>, Inline: [0] -}
49ffa4c64bff188d96a0f2cc0973abfd
  $wrewind ::
    InterpreterBase.Statement
    -> [InterpreterBase.Statement]
    -> InterpreterBase.Env
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((), ([InterpreterBase.Statement], InterpreterBase.Env)) #)
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,U>, Inline: [0] -}
fec14afbe5be4e1b433f9c940468984f
  $wrunInspect ::
    InterpreterBase.Statement
    -> [InterpreterBase.Statement]
    -> InterpreterBase.Env
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((), ([InterpreterBase.Statement], InterpreterBase.Env)) #)
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,U>, Inline: [0] -}
b1f0dd8e08600003bdb0755e764b7f2f
  $wset ::
    InterpreterBase.Name
    -> InterpreterBase.Val
    -> [InterpreterBase.Statement]
    -> InterpreterBase.Env
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either GHC.Base.String ((), InterpreterBase.BigEnv) #)
  {- Arity: 5, Strictness: <L,1*U><L,U><L,U><L,1*U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: InterpreterBase.Name)
                   (ww1 :: InterpreterBase.Val)
                   (ww2 :: [InterpreterBase.Statement])
                   (ww3 :: InterpreterBase.Env)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# w,
                    Data.Either.Right
                      @ [GHC.Types.Char]
                      @ ((),
                         ([InterpreterBase.Statement],
                          Data.Map.Base.Map GHC.Base.String [InterpreterBase.Val]))
                      (GHC.Tuple.(),
                       (ww2,
                        InterpreterBase.$sinsertWith_$sgo10
                          @ [InterpreterBase.Val]
                          InterpreterBase.set2
                          ww
                          (GHC.Types.:
                             @ InterpreterBase.Val
                             ww1
                             (GHC.Types.[] @ InterpreterBase.Val))
                          ww3)) #)) -}
cfde7323d3d7004c4a54aa8b066f00f2
  type BigEnv = ([InterpreterBase.Statement], InterpreterBase.Env)
7d07617fbe861dbe8629fc8b66a2c83d
  type Env =
    Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]
0426d352cf95ed9d432498f57bc0b513
  type Eval a =
    Control.Monad.Trans.Reader.ReaderT
      InterpreterBase.Env
      (Control.Monad.Trans.Except.ExceptT
         GHC.Base.String Data.Functor.Identity.Identity)
      a
9411e785bedd7f51dc2f15a10ee49dce
  data Expr
    = Const InterpreterBase.Val
    | Add InterpreterBase.Expr InterpreterBase.Expr
    | Sub InterpreterBase.Expr InterpreterBase.Expr
    | Mul InterpreterBase.Expr InterpreterBase.Expr
    | Div InterpreterBase.Expr InterpreterBase.Expr
    | And InterpreterBase.Expr InterpreterBase.Expr
    | Or InterpreterBase.Expr InterpreterBase.Expr
    | Not InterpreterBase.Expr
    | Eq InterpreterBase.Expr InterpreterBase.Expr
    | Gt InterpreterBase.Expr InterpreterBase.Expr
    | Lt InterpreterBase.Expr InterpreterBase.Expr
    | Var GHC.Base.String
682dd1b3431c5e7560c3577acc3e57e6
  type Name = GHC.Base.String
c233ce56ce8faf27062c926a50e2b5e7
  class PrettyExpr a b where
    (.*) :: a -> b -> InterpreterBase.Expr
    (.-) :: a -> b -> InterpreterBase.Expr
    {-# MINIMAL (.*), (.-) #-}
9c825e532d61b8e1e6d8de9d9106d183
  type Run a =
    Control.Monad.Trans.State.Lazy.StateT
      InterpreterBase.BigEnv
      (Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO)
      a
e26a477f09bab757a207f96a82b27b42
  class SmartAssignment a where
    assign :: GHC.Base.String -> a -> InterpreterBase.Statement
    {-# MINIMAL assign #-}
e0267278ada4d2cecb8ff825d2e2d0d6
  data Statement
    = Assign GHC.Base.String InterpreterBase.Expr
    | If InterpreterBase.Expr
         InterpreterBase.Statement
         InterpreterBase.Statement
    | While InterpreterBase.Expr InterpreterBase.Statement
    | Print InterpreterBase.Expr
    | Seq InterpreterBase.Statement InterpreterBase.Statement
    | Try InterpreterBase.Statement InterpreterBase.Statement
    | Pass
2592df2e4af9c4d9ca32f8d54a825baa
  data Val = I GHC.Types.Int | B GHC.Types.Bool
8017467bc4f1eaf25fd37e34a8268629
  bool :: GHC.Types.Bool -> InterpreterBase.Expr
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Bool) ->
                 InterpreterBase.Const (InterpreterBase.B x)) -}
1c09db32391ecb41a16f99d7fe227cc0
  eval ::
    InterpreterBase.Expr -> InterpreterBase.Eval InterpreterBase.Val
  {- Arity: 1, Strictness: <S,1*U> -}
0cb2e8bbdea2c6ca058f27920c1988d7
  evalb ::
    (GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool)
    -> InterpreterBase.Expr
    -> InterpreterBase.Expr
    -> Control.Monad.Trans.Reader.ReaderT
         InterpreterBase.Env
         (Control.Monad.Trans.Except.ExceptT
            GHC.Base.String Data.Functor.Identity.Identity)
         InterpreterBase.Val
  {- Arity: 3, Strictness: <L,C(C1(U))><L,1*U><L,1*U>,
     Unfolding: (\ (op :: GHC.Types.Bool
                          -> GHC.Types.Bool -> GHC.Types.Bool)
                   (e0 :: InterpreterBase.Expr)
                   (e1 :: InterpreterBase.Expr) ->
                 let {
                   lvl72 :: InterpreterBase.Eval InterpreterBase.Val
                   = InterpreterBase.eval e1
                 } in
                 let {
                   m1 :: Control.Monad.Trans.Reader.ReaderT
                           (Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val])
                           (Control.Monad.Trans.Except.ExceptT
                              GHC.Base.String Data.Functor.Identity.Identity)
                           InterpreterBase.Val
                   = InterpreterBase.eval e0
                 } in
                 (\ (r1 :: Data.Map.Base.Map
                             InterpreterBase.Name [InterpreterBase.Val]) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                             <Control.Monad.Trans.Except.ExceptT
                                GHC.Base.String Data.Functor.Identity.Identity>_R
                             <InterpreterBase.Val>_N)
                          r1)
                         `cast`
                       (Trans
                            (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <[GHC.Types.Char]>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <InterpreterBase.Val>_N)
                            (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    [GHC.Types.Char] InterpreterBase.Val>_R)) of wild {
                    Data.Either.Left e2
                    -> (Data.Either.Left @ [GHC.Types.Char] @ InterpreterBase.Val e2)
                         `cast`
                       (Trans
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either [GHC.Types.Char] InterpreterBase.Val>_R))
                            (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <[GHC.Types.Char]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <InterpreterBase.Val>_N)))
                    Data.Either.Right x
                    -> case (lvl72
                               `cast`
                             (Control.Monad.Trans.Reader.N:ReaderT[0]
                                  <*>_N
                                  <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                                  <Control.Monad.Trans.Except.ExceptT
                                     GHC.Base.String Data.Functor.Identity.Identity>_R
                                  <InterpreterBase.Val>_N)
                               r1)
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <[GHC.Types.Char]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <InterpreterBase.Val>_N)
                                 (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         [GHC.Types.Char] InterpreterBase.Val>_R)) of wild1 {
                         Data.Either.Left e2
                         -> (Data.Either.Left @ [GHC.Types.Char] @ InterpreterBase.Val e2)
                              `cast`
                            (Trans
                                 (Sym (Data.Functor.Identity.N:Identity[0]
                                           <Data.Either.Either
                                              [GHC.Types.Char] InterpreterBase.Val>_R))
                                 (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <[GHC.Types.Char]>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <InterpreterBase.Val>_N)))
                         Data.Either.Right x1
                         -> case x of wild2 {
                              InterpreterBase.I ipv
                              -> InterpreterBase.evalb1
                                   `cast`
                                 (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <[GHC.Types.Char]>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <InterpreterBase.Val>_N))
                              InterpreterBase.B i0
                              -> case x1 of wild3 {
                                   InterpreterBase.I ipv
                                   -> InterpreterBase.evalb1
                                        `cast`
                                      (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                <[GHC.Types.Char]>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <InterpreterBase.Val>_N))
                                   InterpreterBase.B i1
                                   -> (Data.Either.Right
                                         @ [GHC.Types.Char]
                                         @ InterpreterBase.Val
                                         (InterpreterBase.B (op i0 i1)))
                                        `cast`
                                      (Trans
                                           (Sym (Data.Functor.Identity.N:Identity[0]
                                                     <Data.Either.Either
                                                        [GHC.Types.Char] InterpreterBase.Val>_R))
                                           (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <[GHC.Types.Char]>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <InterpreterBase.Val>_N))) } } } })
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                           <Control.Monad.Trans.Except.ExceptT
                              GHC.Base.String Data.Functor.Identity.Identity>_R
                           <InterpreterBase.Val>_N))) -}
c76768633b53777db08a8f8ac00396ab
  evalb1 ::
    Data.Functor.Identity.Identity
      (Data.Either.Either [GHC.Types.Char] InterpreterBase.Val)
  {- Strictness: x -}
86b8244b6c2eb9db50e0c04f9495d260
  evali ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
    -> InterpreterBase.Expr
    -> InterpreterBase.Expr
    -> Control.Monad.Trans.Reader.ReaderT
         InterpreterBase.Env
         (Control.Monad.Trans.Except.ExceptT
            GHC.Base.String Data.Functor.Identity.Identity)
         InterpreterBase.Val
  {- Arity: 3, Strictness: <L,C(C1(U))><L,1*U><L,1*U>,
     Unfolding: (\ (op :: GHC.Types.Int
                          -> GHC.Types.Int -> GHC.Types.Int)
                   (e0 :: InterpreterBase.Expr)
                   (e1 :: InterpreterBase.Expr) ->
                 let {
                   lvl72 :: InterpreterBase.Eval InterpreterBase.Val
                   = InterpreterBase.eval e1
                 } in
                 let {
                   m1 :: Control.Monad.Trans.Reader.ReaderT
                           (Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val])
                           (Control.Monad.Trans.Except.ExceptT
                              GHC.Base.String Data.Functor.Identity.Identity)
                           InterpreterBase.Val
                   = InterpreterBase.eval e0
                 } in
                 (\ (r1 :: Data.Map.Base.Map
                             InterpreterBase.Name [InterpreterBase.Val]) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                             <Control.Monad.Trans.Except.ExceptT
                                GHC.Base.String Data.Functor.Identity.Identity>_R
                             <InterpreterBase.Val>_N)
                          r1)
                         `cast`
                       (Trans
                            (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <[GHC.Types.Char]>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <InterpreterBase.Val>_N)
                            (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    [GHC.Types.Char] InterpreterBase.Val>_R)) of wild {
                    Data.Either.Left e2
                    -> (Data.Either.Left @ [GHC.Types.Char] @ InterpreterBase.Val e2)
                         `cast`
                       (Trans
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either [GHC.Types.Char] InterpreterBase.Val>_R))
                            (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <[GHC.Types.Char]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <InterpreterBase.Val>_N)))
                    Data.Either.Right x
                    -> case (lvl72
                               `cast`
                             (Control.Monad.Trans.Reader.N:ReaderT[0]
                                  <*>_N
                                  <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                                  <Control.Monad.Trans.Except.ExceptT
                                     GHC.Base.String Data.Functor.Identity.Identity>_R
                                  <InterpreterBase.Val>_N)
                               r1)
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <[GHC.Types.Char]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <InterpreterBase.Val>_N)
                                 (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         [GHC.Types.Char] InterpreterBase.Val>_R)) of wild1 {
                         Data.Either.Left e2
                         -> (Data.Either.Left @ [GHC.Types.Char] @ InterpreterBase.Val e2)
                              `cast`
                            (Trans
                                 (Sym (Data.Functor.Identity.N:Identity[0]
                                           <Data.Either.Either
                                              [GHC.Types.Char] InterpreterBase.Val>_R))
                                 (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <[GHC.Types.Char]>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <InterpreterBase.Val>_N)))
                         Data.Either.Right x1
                         -> case x of wild2 {
                              InterpreterBase.I i0
                              -> case x1 of wild3 {
                                   InterpreterBase.I i1
                                   -> (Data.Either.Right
                                         @ [GHC.Types.Char]
                                         @ InterpreterBase.Val
                                         (InterpreterBase.I (op i0 i1)))
                                        `cast`
                                      (Trans
                                           (Sym (Data.Functor.Identity.N:Identity[0]
                                                     <Data.Either.Either
                                                        [GHC.Types.Char] InterpreterBase.Val>_R))
                                           (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <[GHC.Types.Char]>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <InterpreterBase.Val>_N)))
                                   InterpreterBase.B ipv
                                   -> InterpreterBase.evali1
                                        `cast`
                                      (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                <[GHC.Types.Char]>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <InterpreterBase.Val>_N)) }
                              InterpreterBase.B ipv
                              -> InterpreterBase.evali1
                                   `cast`
                                 (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <[GHC.Types.Char]>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <InterpreterBase.Val>_N)) } } })
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                           <Control.Monad.Trans.Except.ExceptT
                              GHC.Base.String Data.Functor.Identity.Identity>_R
                           <InterpreterBase.Val>_N))) -}
059f052fba1ac73ca2b295a54da55384
  evali1 ::
    Data.Functor.Identity.Identity
      (Data.Either.Either [GHC.Types.Char] InterpreterBase.Val)
  {- Strictness: x -}
0e4a44310107e8470843e4e3f4281816
  evalib ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool)
    -> InterpreterBase.Expr
    -> InterpreterBase.Expr
    -> Control.Monad.Trans.Reader.ReaderT
         InterpreterBase.Env
         (Control.Monad.Trans.Except.ExceptT
            GHC.Base.String Data.Functor.Identity.Identity)
         InterpreterBase.Val
  {- Arity: 3, Strictness: <L,C(C1(U))><L,1*U><L,1*U>,
     Unfolding: (\ (op :: GHC.Types.Int
                          -> GHC.Types.Int -> GHC.Types.Bool)
                   (e0 :: InterpreterBase.Expr)
                   (e1 :: InterpreterBase.Expr) ->
                 let {
                   lvl72 :: InterpreterBase.Eval InterpreterBase.Val
                   = InterpreterBase.eval e1
                 } in
                 let {
                   m1 :: Control.Monad.Trans.Reader.ReaderT
                           (Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val])
                           (Control.Monad.Trans.Except.ExceptT
                              GHC.Base.String Data.Functor.Identity.Identity)
                           InterpreterBase.Val
                   = InterpreterBase.eval e0
                 } in
                 (\ (r1 :: Data.Map.Base.Map
                             InterpreterBase.Name [InterpreterBase.Val]) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.Reader.N:ReaderT[0]
                             <*>_N
                             <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                             <Control.Monad.Trans.Except.ExceptT
                                GHC.Base.String Data.Functor.Identity.Identity>_R
                             <InterpreterBase.Val>_N)
                          r1)
                         `cast`
                       (Trans
                            (Control.Monad.Trans.Except.N:ExceptT[0]
                                 <[GHC.Types.Char]>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <InterpreterBase.Val>_N)
                            (Data.Functor.Identity.N:Identity[0]
                                 <Data.Either.Either
                                    [GHC.Types.Char] InterpreterBase.Val>_R)) of wild {
                    Data.Either.Left e2
                    -> (Data.Either.Left @ [GHC.Types.Char] @ InterpreterBase.Val e2)
                         `cast`
                       (Trans
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either [GHC.Types.Char] InterpreterBase.Val>_R))
                            (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <[GHC.Types.Char]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <InterpreterBase.Val>_N)))
                    Data.Either.Right x
                    -> case (lvl72
                               `cast`
                             (Control.Monad.Trans.Reader.N:ReaderT[0]
                                  <*>_N
                                  <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                                  <Control.Monad.Trans.Except.ExceptT
                                     GHC.Base.String Data.Functor.Identity.Identity>_R
                                  <InterpreterBase.Val>_N)
                               r1)
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Except.N:ExceptT[0]
                                      <[GHC.Types.Char]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <InterpreterBase.Val>_N)
                                 (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         [GHC.Types.Char] InterpreterBase.Val>_R)) of wild1 {
                         Data.Either.Left e2
                         -> (Data.Either.Left @ [GHC.Types.Char] @ InterpreterBase.Val e2)
                              `cast`
                            (Trans
                                 (Sym (Data.Functor.Identity.N:Identity[0]
                                           <Data.Either.Either
                                              [GHC.Types.Char] InterpreterBase.Val>_R))
                                 (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <[GHC.Types.Char]>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <InterpreterBase.Val>_N)))
                         Data.Either.Right x1
                         -> case x of wild2 {
                              InterpreterBase.I i0
                              -> case x1 of wild3 {
                                   InterpreterBase.I i1
                                   -> (Data.Either.Right
                                         @ [GHC.Types.Char]
                                         @ InterpreterBase.Val
                                         (InterpreterBase.B (op i0 i1)))
                                        `cast`
                                      (Trans
                                           (Sym (Data.Functor.Identity.N:Identity[0]
                                                     <Data.Either.Either
                                                        [GHC.Types.Char] InterpreterBase.Val>_R))
                                           (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                     <[GHC.Types.Char]>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <InterpreterBase.Val>_N)))
                                   InterpreterBase.B ipv
                                   -> InterpreterBase.evalib1
                                        `cast`
                                      (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                <[GHC.Types.Char]>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <InterpreterBase.Val>_N)) }
                              InterpreterBase.B ipv
                              -> InterpreterBase.evalib1
                                   `cast`
                                 (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                           <[GHC.Types.Char]>_N
                                           <Data.Functor.Identity.Identity>_R
                                           <InterpreterBase.Val>_N)) } } })
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <*>_N
                           <Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                           <Control.Monad.Trans.Except.ExceptT
                              GHC.Base.String Data.Functor.Identity.Identity>_R
                           <InterpreterBase.Val>_N))) -}
cafd74d3ac5ce6a00f4ea0cbe0713937
  evalib1 ::
    Data.Functor.Identity.Identity
      (Data.Either.Either [GHC.Types.Char] InterpreterBase.Val)
  {- Strictness: x -}
e03550f73cd021e9ad334017b983c138
  exec :: InterpreterBase.Statement -> InterpreterBase.Run ()
  {- Arity: 1, Strictness: <S,1*U> -}
a255840d91488def2366c300761d8659
  execCheck :: InterpreterBase.Statement -> InterpreterBase.Run ()
  {- Arity: 1, Strictness: <L,U> -}
ac5918b92dc3ce3e1618c3acbadfaeb5
  inspectHistory ::
    InterpreterBase.Statement -> InterpreterBase.Run ()
  {- Arity: 3, Strictness: <L,U><S,1*U(U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.inspectHistory1
                  `cast`
                (<InterpreterBase.Statement>_R
                 ->_R Trans
                          (<([InterpreterBase.Statement], InterpreterBase.Env)>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either
                                                 [GHC.Types.Char]
                                                 ((),
                                                  ([InterpreterBase.Statement],
                                                   InterpreterBase.Env))>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <[GHC.Types.Char]>_N
                                              <GHC.Types.IO>_R
                                              <((),
                                                ([InterpreterBase.Statement],
                                                 InterpreterBase.Env))>_N)))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <([InterpreterBase.Statement], InterpreterBase.Env)>_N
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <()>_N))) -}
45f2aa989c25bbdbd4bf6e446d7d966d
  inspectHistory1 ::
    InterpreterBase.Statement
    -> ([InterpreterBase.Statement], InterpreterBase.Env)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((), ([InterpreterBase.Statement], InterpreterBase.Env)) #)
  {- Arity: 3, Strictness: <L,U><S,1*U(U,U)><S,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: InterpreterBase.Statement)
                   (w1 :: ([InterpreterBase.Statement], InterpreterBase.Env))
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w1 of ww { (,) ww1 ww2 ->
                 InterpreterBase.$winspectHistory w ww1 ww2 w2 }) -}
ff0f7e0f7b8f93527f97cffaf0b0523a
  int :: GHC.Types.Int -> InterpreterBase.Expr
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Int) ->
                 InterpreterBase.Const (InterpreterBase.I x)) -}
a440aac396cbea47fe54f8f0b8832633
  lookup ::
    GHC.Base.Monad m =>
    [GHC.Types.Char] -> Data.Map.Base.Map [GHC.Types.Char] [a] -> m a
  {- Arity: 3,
     Strictness: <S,1*U(A,A,A,1*C1(U),1*C1(U))><S,U><S,1*U>,
     Unfolding: (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (k :: [GHC.Types.Char])
                   (t :: Data.Map.Base.Map [GHC.Types.Char] [a]) ->
                 case InterpreterBase.$slookup1 @ [a] k t of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.fail
                        @ m
                        $dMonad
                        @ a
                        (InterpreterBase.lookup3
                           @ [GHC.Types.Char]
                           (GHC.Types.: @ GHC.Types.Char)
                           k)
                   GHC.Base.Just ds
                   -> case ds of wild1 {
                        [] -> InterpreterBase.lookup2 @ m @ a
                        : x ds1 -> GHC.Base.return @ m $dMonad @ a x } }) -}
9904b0fe46b6ec1c71a0e720f51c6890
  lookup2 :: m a
  {- Strictness: x -}
9a47046059a3ab15ed1a68ddb5681f2d
  lookup3 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString# @ b "Unknown variable "# c n) -}
3e93c7b9a0aeb5107810029e8955fff3
  printEnvironment :: InterpreterBase.Env -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.printEnvironment1
                  `cast`
                (<Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
341dc226089a5d032cb1d6e2f1385564
  printEnvironment1 ::
    Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Map.Base.Map
                           InterpreterBase.Name [InterpreterBase.Val])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Data.Map.Base.$fShowMap_$cshow
                      @ [GHC.Types.Char]
                      @ [InterpreterBase.Val]
                      GHC.Show.$fShow[]_$s$fShow[]1
                      InterpreterBase.$s$fShow[]
                      x)
                   GHC.Types.True
                   eta) -}
157d88469be1845e4a3f818d7e4b56b0
  record :: InterpreterBase.Statement -> InterpreterBase.Run ()
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U(U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.record1
                  `cast`
                (<InterpreterBase.Statement>_R
                 ->_R Trans
                          (<([InterpreterBase.Statement], InterpreterBase.Env)>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either
                                                 [GHC.Types.Char]
                                                 ((),
                                                  ([InterpreterBase.Statement],
                                                   InterpreterBase.Env))>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <[GHC.Types.Char]>_N
                                              <GHC.Types.IO>_R
                                              <((),
                                                ([InterpreterBase.Statement],
                                                 InterpreterBase.Env))>_N)))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <([InterpreterBase.Statement], InterpreterBase.Env)>_N
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <()>_N))) -}
b23773aed07274c5d7edcf49bacf02b0
  record1 ::
    InterpreterBase.Statement
    -> ([InterpreterBase.Statement], InterpreterBase.Env)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((), ([InterpreterBase.Statement], InterpreterBase.Env)) #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U(U,U)><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: InterpreterBase.Statement)
                   (eta :: ([InterpreterBase.Statement], InterpreterBase.Env))
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case eta of wild { (,) h st ->
                 (# eta1,
                    Data.Either.Right
                      @ [GHC.Types.Char]
                      @ ((),
                         ([InterpreterBase.Statement],
                          Data.Map.Base.Map GHC.Base.String [InterpreterBase.Val]))
                      (GHC.Tuple.(),
                       (GHC.Types.: @ InterpreterBase.Statement s h, st)) #) }) -}
54d1a0c67f22b4f7cc4bf3ad634fd72e
  reverse :: InterpreterBase.Statement -> InterpreterBase.Run ()
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.reverse1
                  `cast`
                (<InterpreterBase.Statement>_R
                 ->_R Trans
                          (<InterpreterBase.BigEnv>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either
                                                 GHC.Base.String ((), InterpreterBase.BigEnv)>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <GHC.Base.String>_N
                                              <GHC.Types.IO>_R
                                              <((), InterpreterBase.BigEnv)>_N)))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <InterpreterBase.BigEnv>_N
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <()>_N))) -}
7cc7859d5d831248e6ae1c7c73503f87
  reverse1 ::
    InterpreterBase.Statement
    -> InterpreterBase.BigEnv
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either GHC.Base.String ((), InterpreterBase.BigEnv) #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U)><S,U>,
     Unfolding: (\ (ds :: InterpreterBase.Statement)
                   (eta :: InterpreterBase.BigEnv)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case ds of wild {
                   DEFAULT
                   -> (# eta1,
                         Data.Either.Right
                           @ [GHC.Types.Char]
                           @ ((), ([InterpreterBase.Statement], InterpreterBase.Env))
                           (GHC.Tuple.(), eta) #)
                   InterpreterBase.Assign s i
                   -> case eta of wild1 { (,) h st ->
                      (# eta1,
                         Data.Either.Right
                           @ [GHC.Types.Char]
                           @ ((),
                              ([InterpreterBase.Statement],
                               Data.Map.Base.Map GHC.Base.String [InterpreterBase.Val]))
                           (GHC.Tuple.(),
                            (h,
                             InterpreterBase.$sinsertWith_$sgo10
                               @ [InterpreterBase.Val]
                               InterpreterBase.reverse5
                               s
                               InterpreterBase.reverse2
                               st)) #) } }) -}
527037f59141100eceb8cf9bccfe1535
  reverse2 :: [InterpreterBase.Val]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ InterpreterBase.Val
                   InterpreterBase.reverse3
                   (GHC.Types.[] @ InterpreterBase.Val)) -}
c4abe60b21f5720b5ec9d7da0ad29cea
  reverse3 :: InterpreterBase.Val
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (InterpreterBase.I InterpreterBase.reverse4) -}
caa41e4d78a4a0a9bbc82561124e3fe5
  reverse4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 999#) -}
f1f0b54667ed3e437cc6f373e76caaa1
  reverse5 ::
    GHC.Base.String
    -> [InterpreterBase.Val]
    -> [InterpreterBase.Val]
    -> [InterpreterBase.Val]
  {- Arity: 3,
     Unfolding: (\ (ds :: GHC.Base.String)[OneShot]
                   (x' :: [InterpreterBase.Val])[OneShot]
                   (y' :: [InterpreterBase.Val])[OneShot] ->
                 GHC.List.tail @ InterpreterBase.Val y') -}
f282b44ea7427d3be33bf4008ff59fac
  rewind :: InterpreterBase.Statement -> InterpreterBase.Run ()
  {- Arity: 3, Strictness: <L,U><S(SL),1*U(1*U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.rewind1
                  `cast`
                (<InterpreterBase.Statement>_R
                 ->_R Trans
                          (<([InterpreterBase.Statement], InterpreterBase.Env)>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either
                                                 [GHC.Types.Char]
                                                 ((),
                                                  ([InterpreterBase.Statement],
                                                   InterpreterBase.Env))>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <[GHC.Types.Char]>_N
                                              <GHC.Types.IO>_R
                                              <((),
                                                ([InterpreterBase.Statement],
                                                 InterpreterBase.Env))>_N)))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <([InterpreterBase.Statement], InterpreterBase.Env)>_N
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <()>_N))) -}
9823f6fe9c247ed5b6f8f3b773f0dd37
  rewind1 ::
    InterpreterBase.Statement
    -> ([InterpreterBase.Statement], InterpreterBase.Env)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((), ([InterpreterBase.Statement], InterpreterBase.Env)) #)
  {- Arity: 3, Strictness: <L,U><S(SL),1*U(1*U,U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: InterpreterBase.Statement)
                   (w1 :: ([InterpreterBase.Statement], InterpreterBase.Env))
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w1 of ww { (,) ww1 ww2 ->
                 InterpreterBase.$wrewind w ww1 ww2 w2 }) -}
00f8763d23a8cafd45a45bd8b057a81f
  run :: InterpreterBase.Statement -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.run1
                  `cast`
                (<InterpreterBase.Statement>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
cf96fa552fbfe7517e0062f9df1d638d
  run1 ::
    InterpreterBase.Statement
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (program :: InterpreterBase.Statement)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case ((InterpreterBase.exec program)
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <InterpreterBase.BigEnv>_N
                            <Control.Monad.Trans.Except.ExceptT GHC.Base.String GHC.Types.IO>_R
                            <()>_N)
                         InterpreterBase.run3)
                        `cast`
                      (Trans
                           (Control.Monad.Trans.Except.N:ExceptT[0]
                                <GHC.Base.String>_N
                                <GHC.Types.IO>_R
                                <((), InterpreterBase.BigEnv)>_N)
                           (GHC.Types.N:IO[0]
                                <Data.Either.Either
                                   GHC.Base.String ((), InterpreterBase.BigEnv)>_R))
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   Data.Either.Left exn
                   -> GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows8
                           (GHC.Show.showLitString
                              (GHC.CString.unpackAppendCString# "Uncaught exception: "# exn)
                              InterpreterBase.run2))
                        GHC.Types.True
                        ipv
                   Data.Either.Right ds
                   -> case ds of wild1 { (,) ds2 env ->
                      case ds2 of wild2 { () -> (# ipv, GHC.Tuple.() #) } } } }) -}
f65b7f23869e4902f30e7b5f8309fec2
  run2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows8
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8d3b828efb8f7cf9da725da1f8bb5b90
  run3 ::
    ([InterpreterBase.Statement],
     Data.Map.Base.Map InterpreterBase.Name [InterpreterBase.Val])
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Types.[] @ InterpreterBase.Statement,
                  Data.Map.Base.Tip
                    @ InterpreterBase.Name
                    @ [InterpreterBase.Val])) -}
292afd958c05e87ca806c33c5a2d2acb
  runEval ::
    r
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            e Data.Functor.Identity.Identity)
         a
    -> Data.Either.Either e a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.runEval1
                  `cast`
                (forall (e :: <*>_N) (a :: <*>_N) (r :: <*>_N).
                 <r>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT
                         r
                         (Control.Monad.Trans.Except.ExceptT
                            e Data.Functor.Identity.Identity)
                         a>_R
                 ->_R Trans
                          (Control.Monad.Trans.Except.N:ExceptT[0]
                               <e>_N <Data.Functor.Identity.Identity>_R <a>_N)
                          (Data.Functor.Identity.N:Identity[0]
                               <Data.Either.Either e a>_R)) -}
60e559980f03e2389641ddaf5b3b9aa1
  runEval1 ::
    r
    -> Control.Monad.Trans.Reader.ReaderT
         r
         (Control.Monad.Trans.Except.ExceptT
            e Data.Functor.Identity.Identity)
         a
    -> Control.Monad.Trans.Except.ExceptT
         e Data.Functor.Identity.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ @ e
                   @ a
                   @ r
                   (env :: r)
                   (ex :: Control.Monad.Trans.Reader.ReaderT
                            r
                            (Control.Monad.Trans.Except.ExceptT
                               e Data.Functor.Identity.Identity)
                            a) ->
                 ex
                   `cast`
                 (Control.Monad.Trans.Reader.N:ReaderT[0]
                      <*>_N
                      <r>_R
                      <Control.Monad.Trans.Except.ExceptT
                         e Data.Functor.Identity.Identity>_R
                      <a>_N)
                   env) -}
3b916be925c1d16dc2d82660ca210581
  runInspect :: InterpreterBase.Statement -> InterpreterBase.Run ()
  {- Arity: 3, Strictness: <L,U><S,1*U(U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.runInspect1
                  `cast`
                (<InterpreterBase.Statement>_R
                 ->_R Trans
                          (<([InterpreterBase.Statement], InterpreterBase.Env)>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either
                                                 [GHC.Types.Char]
                                                 ((),
                                                  ([InterpreterBase.Statement],
                                                   InterpreterBase.Env))>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <[GHC.Types.Char]>_N
                                              <GHC.Types.IO>_R
                                              <((),
                                                ([InterpreterBase.Statement],
                                                 InterpreterBase.Env))>_N)))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <([InterpreterBase.Statement], InterpreterBase.Env)>_N
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <()>_N))) -}
99d3d56c9e423c9deca5cae3f6ce55b1
  runInspect1 ::
    InterpreterBase.Statement
    -> ([InterpreterBase.Statement], InterpreterBase.Env)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((), ([InterpreterBase.Statement], InterpreterBase.Env)) #)
  {- Arity: 3, Strictness: <L,U><S,1*U(U,U)><S,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: InterpreterBase.Statement)
                   (w1 :: ([InterpreterBase.Statement], InterpreterBase.Env))
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w1 of ww { (,) ww1 ww2 ->
                 InterpreterBase.$wrunInspect w ww1 ww2 w2 }) -}
cefa610f1fca322442a1e388a4027723
  runRun ::
    Control.Monad.Trans.State.Lazy.StateT
      ([t], Data.Map.Base.Map k a1)
      (Control.Monad.Trans.Except.ExceptT e m)
      a
    -> m (Data.Either.Either e (a, ([t], Data.Map.Base.Map k a1)))
  {- Arity: 1, HasNoCafRefs, Strictness: <C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.runRun1
                  `cast`
                (forall (e :: <*>_N) (m :: <*
                                            -> *>_N) (a :: <*>_N) (t :: <*>_N) (k :: <*>_N) (a1 :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    ([t], Data.Map.Base.Map k a1)
                    (Control.Monad.Trans.Except.ExceptT e m)
                    a>_R
                 ->_R Control.Monad.Trans.Except.N:ExceptT[0]
                          <e>_N <m>_R <(a, ([t], Data.Map.Base.Map k a1))>_N) -}
ea2b5fa8170dc1a898329369b9392c6d
  runRun1 ::
    Control.Monad.Trans.State.Lazy.StateT
      ([t], Data.Map.Base.Map k a1)
      (Control.Monad.Trans.Except.ExceptT e m)
      a
    -> Control.Monad.Trans.Except.ExceptT
         e m (a, ([t], Data.Map.Base.Map k a1))
  {- Arity: 1, HasNoCafRefs, Strictness: <C(S),1*C1(U)>,
     Unfolding: InlineRule (1, True, True)
                (\ @ e
                   @ (m :: * -> *)
                   @ a
                   @ t
                   @ k
                   @ a1
                   (p :: Control.Monad.Trans.State.Lazy.StateT
                           ([t], Data.Map.Base.Map k a1)
                           (Control.Monad.Trans.Except.ExceptT e m)
                           a) ->
                 p `cast`
                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                      <([t], Data.Map.Base.Map k a1)>_N
                      <Control.Monad.Trans.Except.ExceptT e m>_R
                      <a>_N)
                   (InterpreterBase.runRun2 @ t @ a1 @ k)) -}
54438e6ea6d3391a64c947dd3befe5e4
  runRun2 :: ([t], Data.Map.Base.Map k a)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ t @ a @ k ->
                 (GHC.Types.[] @ t, Data.Map.Base.Tip @ k @ a)) -}
caebf394007a3869c3272603a8a49db2
  set ::
    (InterpreterBase.Name, InterpreterBase.Val)
    -> InterpreterBase.Run ()
  {- Arity: 3, Strictness: <S,1*U(1*U,U)><S,1*U(U,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                InterpreterBase.set1
                  `cast`
                (<(InterpreterBase.Name, InterpreterBase.Val)>_R
                 ->_R Trans
                          (<InterpreterBase.BigEnv>_R
                           ->_R Trans
                                    (Sym (GHC.Types.N:IO[0]
                                              <Data.Either.Either
                                                 GHC.Base.String ((), InterpreterBase.BigEnv)>_R))
                                    (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                              <GHC.Base.String>_N
                                              <GHC.Types.IO>_R
                                              <((), InterpreterBase.BigEnv)>_N)))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <InterpreterBase.BigEnv>_N
                                    <Control.Monad.Trans.Except.ExceptT
                                       GHC.Base.String GHC.Types.IO>_R
                                    <()>_N))) -}
154c78078354d88bab845564d0894ec2
  set1 ::
    (InterpreterBase.Name, InterpreterBase.Val)
    -> InterpreterBase.BigEnv
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either GHC.Base.String ((), InterpreterBase.BigEnv) #)
  {- Arity: 3, Strictness: <S,1*U(1*U,U)><S,1*U(U,1*U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: (InterpreterBase.Name, InterpreterBase.Val))
                   (w1 :: InterpreterBase.BigEnv)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 InterpreterBase.$wset ww1 ww2 ww4 ww5 w2 } }) -}
6f86b536aa296161181069313ad8b43d
  set2 ::
    InterpreterBase.Name
    -> [InterpreterBase.Val]
    -> [InterpreterBase.Val]
    -> [InterpreterBase.Val]
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ (ds :: InterpreterBase.Name)[OneShot]
                   (x' :: [InterpreterBase.Val])[OneShot]
                   (y' :: [InterpreterBase.Val])[OneShot] ->
                 GHC.Base.++ @ InterpreterBase.Val x' y') -}
e8ab33f1e89bc6b7b2fc44298c867f87
  var :: GHC.Base.String -> InterpreterBase.Expr
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m12,
     Unfolding: InlineRule (0, True, True) InterpreterBase.Var -}
instance [safe] GHC.Classes.Eq [InterpreterBase.Expr]
  = InterpreterBase.$fEqExpr
instance [safe] GHC.Classes.Eq [InterpreterBase.Statement]
  = InterpreterBase.$fEqStatement
instance [safe] GHC.Classes.Eq [InterpreterBase.Val]
  = InterpreterBase.$fEqVal
instance [safe] GHC.Base.Monoid [InterpreterBase.Statement]
  = InterpreterBase.$fMonoidStatement
instance [safe] InterpreterBase.PrettyExpr [[], GHC.Types.Int]
  = InterpreterBase.$fPrettyExpr[]Int
instance [safe] InterpreterBase.PrettyExpr [[], []]
  = InterpreterBase.$fPrettyExpr[][]
instance [safe] GHC.Read.Read [InterpreterBase.Expr]
  = InterpreterBase.$fReadExpr
instance [safe] GHC.Read.Read [InterpreterBase.Statement]
  = InterpreterBase.$fReadStatement
instance [safe] GHC.Read.Read [InterpreterBase.Val]
  = InterpreterBase.$fReadVal
instance [safe] GHC.Show.Show [InterpreterBase.Expr]
  = InterpreterBase.$fShowExpr
instance [safe] GHC.Show.Show [InterpreterBase.Statement]
  = InterpreterBase.$fShowStatement
instance [safe] GHC.Show.Show [InterpreterBase.Val]
  = InterpreterBase.$fShowVal
instance [safe] InterpreterBase.SmartAssignment [GHC.Types.Bool]
  = InterpreterBase.$fSmartAssignmentBool
instance [safe] InterpreterBase.SmartAssignment [InterpreterBase.Expr]
  = InterpreterBase.$fSmartAssignmentExpr
instance [safe] InterpreterBase.SmartAssignment [GHC.Types.Int]
  = InterpreterBase.$fSmartAssignmentInt
"SPEC/InterpreterBase $fShow[] @ Val" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                   InterpreterBase.Val)
  GHC.Show.$fShow[] @ InterpreterBase.Val $dShow
  = InterpreterBase.$s$fShow[]
"SPEC/InterpreterBase $fShow[]_$cshow @ Statement" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                                InterpreterBase.Statement)
  GHC.Show.$fShow[]_$cshow @ InterpreterBase.Statement $dShow
  = InterpreterBase.$s$fShow[]_$s$fShow[]_$cshow1
"SPEC/InterpreterBase $fShow[]_$cshow @ Val" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                          InterpreterBase.Val)
  GHC.Show.$fShow[]_$cshow @ InterpreterBase.Val $dShow
  = InterpreterBase.$s$fShow[]_$s$fShow[]_$cshow
"SPEC/InterpreterBase $fShow[]_$cshowList @ Val" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                              InterpreterBase.Val)
  GHC.Show.$fShow[]_$cshowList @ InterpreterBase.Val $dShow
  = InterpreterBase.$s$fShow[]_$s$fShow[]_$cshowList
"SPEC/InterpreterBase $fShow[]_$cshowsPrec @ Val" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                               InterpreterBase.Val)
  GHC.Show.$fShow[]_$cshowsPrec @ InterpreterBase.Val $dShow
  = InterpreterBase.$s$fShow[]_$s$fShow[]_$cshowsPrec
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

